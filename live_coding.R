

##
## Part 1: Introduction to NIMBLE
##

library(nimble)

code <- nimbleCode({
  for (i in 1:G) {
     ## prior for hyperparameters
     ## such gamma priors are not generally recommended, but
     ## these are the priors from the original example
     a[i] ~ dgamma(1, .001)
     b[i] ~ dgamma(1, .001)
     ##
     for (j in 1:N) {
         ## likelihood (data model)
        r[i,j] ~ dbin(p[i,j], n[i,j])
        ## latent process (random effects)
        p[i,j] ~ dbeta(a[i], b[i])
     }
   }
})

n <- matrix(c(13, 12, 12, 11, 9, 10, 
              9, 9, 8, 11, 8, 10, 13, 10, 12, 9, 10, 9, 10, 5, 9, 9, 13, 
              7, 5, 10, 7, 6, 10, 10, 10, 7), nrow = 2)

r <- matrix(c(13, 12, 12, 11, 9, 10, 9, 9, 8, 10, 8, 9, 
              12, 9, 11, 8, 9, 8, 9, 4, 8, 7, 11, 4, 4, 5, 5, 3, 7, 3, 7, 0), 
            nrow = 2)


## code, constants, data, inits
N <- dim(r)[2]
G <- dim(r)[1]

constants <- list(G = G, N = N, n = n)

data <- list(r = r)

inits <- list(a = c(2, 2), b = c(2, 2),
              p = array(0.5, c(G,N)))



## NIMBLE model object: Rmodel

Rmodel <- nimbleModel(code, constants,
                      data, inits)

Rmodel$calculate()   ## -160.7914


## compiled model object: Cmodel

Cmodel <- compileNimble(Rmodel)

Cmodel$calculate()

Rmodel$a

## calculate() calculates model log-densities
Rmodel$calculate('a')

dgamma(2, 1, 0.001, log = TRUE) + dgamma(2, 1, 0.001, log = TRUE)

Rmodel$a[1] <- 100

Rmodel$a

Rmodel$calculate('a[1]')

dgamma(100, 1, 0.001, log = TRUE)

## simulate() does random number generation
## simulates from the prior distribution

set.seed(0)

Rmodel$a
Rmodel$simulate('a')
Rmodel$a

set.seed(0)
rgamma(2, 1, 0.001)

Rmodel$a
Rmodel$b
Rmodel$p
Rmodel$r
## no arguments: simulate *all* (non-data) variables
Rmodel$simulate()
Rmodel$a
Rmodel$b
Rmodel$p
Rmodel$r

Rmodel$isData('a')
Rmodel$isData('p')
Rmodel$isData('r')

Rmodel$resetData()

Rmodel$simulate()  ## simulates over everything (including r)
Rmodel$a
Rmodel$b
Rmodel$p
Rmodel$r

## simple simulation using the model
for(i in 1:10) {
    Rmodel$a[1] <- i
    Rmodel$simulate()
    y <- Rmodel$r[1, 1]  ## then save y values
}
    


Rmodel$p
Rmodel$calculate('a')   # log-prior density
Rmodel$getLogProb('a')

Rmodel$a <- c(300, 3)
Rmodel$a
Rmodel$getLogProb('a')
Rmodel$calculate('a')   # log-prior density

## so the calculations are reproducible
set.seed(1)

Rmodel$simulate('p')  # simulate from prior
Rmodel$p
Rmodel$getLogProb('p')  # log prob not yet updated!
Rmodel$calculate('p')   # update it
Rmodel$getLogProb('p')  # now we're good



## configuring and building an MCMC

Rmodel <- nimbleModel(code, constants, data, inits)

conf <- configureMCMC(Rmodel)

## configure monitors
conf$printMonitors()

## configure samplers
conf$printSamplers()
conf$printSamplers(byType = TRUE)

Rmcmc <- buildMCMC(conf)

## Rmcmc is executable !
## .... but.... it's slow!

Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project=Rmodel)

set.seed(0)
Rmodel$a
system.time(Rsamples <- runMCMC(Rmcmc, 100))
Rmodel$a
dim(Rsamples)

set.seed(0)
Cmodel$a
system.time(Csamples <- runMCMC(Cmcmc, 100000))
Cmodel$a
dim(Csamples)

## other functions of runMCMC():

samples <- runMCMC(Cmcmc, 10000)

samplesSummary(samples)

library(basicMCMCplots)

basicMCMCplots::samplesPlot(samples)
basicMCMCplots::chainsPlot(samples)

## multiple chains
samplesList <- runMCMC(Cmcmc, 10000, nchains=3)

basicMCMCplots::chainsPlot(samplesList)

cor(samplesList[[3]])


## basic MCMC workflow:
Rmodel <- nimbleModel(code, constants, data, inits)
conf <- configureMCMC(Rmodel)
##conf$printMonitors()
##conf$printSamplers()
##conf$printSamplers(byType = TRUE)
Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project=Rmodel)
samples <- runMCMC(Cmcmc, 10000)


Rmodel <- nimbleModel(code, constants, data, inits)
conf <- configureMCMC(Rmodel)
conf$printSamplers()
conf$printSamplers(byType = TRUE)

conf$printSamplers(c('a', 'b'))
conf$removeSamplers('a[1]', 'b[1]')
conf$printSamplers(c('a', 'b'))
conf$printSamplers()

conf$addSampler(target = 'a[1]',
                type = 'RW',
                control = list(
                    logScale = TRUE,
                    adaptInterval = 100))

conf$addSampler(target = 'b[1]',
                type = 'RW',
                control = list(
                    logScale = TRUE,
                    adaptInterval = 100))
                    
conf$printSamplers()

Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project=Rmodel)

samples <- runMCMC(Cmcmc, 20000, nchains = 3, nburnin=10000)

chainsPlot(samples, c('a', 'b'))

## let's try joint (block) sampling
## (this is HUGE; the ability to do this) !!!

Rmodel <- nimbleModel(code, constants, data, inits)
conf <- configureMCMC(Rmodel)
conf$printSamplers(c('a', 'b'))
conf$removeSamplers('a', 'b')

conf$printSamplers()

conf$addSampler(target = c('a[1]', 'b[1]'),
                type = 'RW_block')

conf$addSampler(target = c('a[2]', 'b[2]'),
                type = 'RW_block')

conf$printSamplers()

Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project=Rmodel)

samplesList <- runMCMC(Cmcmc, 20000, nchains = 3, nburnin=10000)

chainsPlot(samplesList)

samplesPlot(samplesList[[1]][1:1000,1])



## slice sampler
## this is what JAGS uses by default

Rmodel <- nimbleModel(code, constants, data, inits)
conf <- configureMCMC(Rmodel, nodes = NULL)
conf$printSamplers()

## this is the default MCMC monitors:
Rmodel$getNodeNames(topOnly = TRUE)

nodes <- Rmodel$getNodeNames(includeData = FALSE)
nodes

for(n in nodes) {
    conf$addSampler(target = n, type = 'slice')
}
conf$printSamplers()
conf$printSamplers(byType = TRUE)

conf <- configureMCMC(Rmodel, onlySlice = TRUE)
conf$printSamplers(byType = TRUE)

## effective sample size

library(coda)

str(samplesList)

chainsPlot(samplesList)

## samplesSummary
## samplesPlot
## chainsPlot
## chainsSummary

chainsSummary(samplesList)

dim(samplesList[[1]])


effectiveSize(samplesList[[1]])

## convergence diagnostic
## the "state of the art" for showing "convergence"
coda::gelman.diag


## nimbleMCMC
samples <- nimbleMCMC(code, constants, data, inits,
                      niter = 10000,
                      nchains = 3,
                      WAIC = TRUE)


Rmodel <- nimbleModel(code, constants, data, inits)

conf <- configureMCMC(Rmodel, enableWAIC = TRUE)
conf$addMonitors('p')
Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project=Rmodel)

out <- runMCMC(Cmcmc, 10000,
               nchains = 3,
               samples = FALSE,
               summary = TRUE,
               WAIC = TRUE)

str(out)

names(out)

out$summary















